
1. 명령 실행과정
	1. 명령어는 PC에서 명령어주소를 읽고 
	2. 명령어에 적힌 레지스터를 읽어서 
	3. (디코더!!!) 회로에 넣어 어떤 레지스터값을 읽을지 정한다.
    2.
		PC = PC+4 or target Adress


ALU : 계산 역할 cpu, 주소 연산에도 사용한다.

3 . CPU 설계도 input output 확인

	1) 멀티플렉서 확인
	2) 각각의 요소를 어떤동작할지 정해주는 control 요소	
		명령어에서 input받고 7개의 선으로 출력된다. 사용되는 선에는 1로 입력되어 그 문장이 실행된다.
			1. regwrite : add,sub,mul,load 명령어 4개 
			2. Memread : load
			3. Memwrite : stroe
			4. ALU operation : 복잡함 ㅡㅡ

	3) Multi bit, Single bit 확인!!!!
		1 bit면 Single bit 신호이다.(주소나 데이터는 멀티비트)

	4) 컴비네이션 서킷 3가지
		1. 멀티 플렉서 3개
		2. add(브랜치)
		3. ALU, add
	5) 나머지는 시퀸셜 서킷이다.


4. datapath(데이터 통로) : 데이터와, 주소가 같이 지나간다.

5. 명령어 가져오는 과정
	1) 명령어를 읽어온다.

6. add 또는 load , store 
	1) add명령어 : 2개의 레지스터를 읽고 ALU에서 연산다음 결과 데이터를 레지스터 메모리에 저장
	2) load, store : offset의 비트는 12비트라 32또는 64로 확장한다음 ALU에서 연산한다.
	3) Branch 명령어 : ALU에 두개의 레지스터 값을 sub한다음 0인지 확인 0이라면 pc에 targetoffset 더해서 다음명령수행, 아니라면 pc += 4 한다.


7. 요소 구성 특징 
	1) 데이터를 어디서 받을지 
		: 멀티 플렉서
	2)  명령어 메모리와, 데이터 메모리가 분리되어있다 
		: 명령어 메모리는 가져오기만하고 데이터 메모리는 쓰기도 하기 때문

8. Control 신호 만들기
	1) ALU : 4가지 명령일때 각각의 컨트롤 센서
	2) Main Control(나머지) :  7가지의 컨트롤 센서(Branch,MemRead.......), 명령어의 opcode만보고 출력값이 결정된다.
	3) 30p의 테이블 채워야함
	
ALUSrc = 
Memto-reg = 메모리값을 레지스터에 저장?
reg- write = 레지스터에 값 저장?
Mem- Read = 메모리 값 읽음?
Mem - write = 메모리에 값 저장
Brach = 점프 띄어?
aluop1-2 1 0 = fuction에 따라
aluop1-2 0 0 = 무조건 add
aluop1-2 0 0 = ''
aluop1-2 1 0 = 무조건 sub
		